<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <title>3D Tank & Plane Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

<script>
/* ---------------------------
   SCENĂ 3D + CAMERĂ + LUMINĂ
-----------------------------*/
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 20, 40);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ---------------------------
        LUMINĂ
-----------------------------*/
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
scene.add(light);

/* ---------------------------
        TEREN
-----------------------------*/
const groundGeom = new THREE.PlaneGeometry(200, 200);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
const ground = new THREE.Mesh(groundGeom, groundMat);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

/* ---------------------------
        TANK 3D
-----------------------------*/
const tankGeom = new THREE.BoxGeometry(3, 2, 5);
const tankMat = new THREE.MeshStandardMaterial({ color: 0x5555ff });
const tank = new THREE.Mesh(tankGeom, tankMat);
tank.position.y = 1;
scene.add(tank);

/* ---------------------------
        AVION 3D
-----------------------------*/
const planeGeom = new THREE.BoxGeometry(6, 1, 6);
const planeMat = new THREE.MeshStandardMaterial({ color: 0xff5555 });
const plane = new THREE.Mesh(planeGeom, planeMat);
plane.position.y = 5;
plane.position.z = -10;
scene.add(plane);

/* ---------------------------
        ȚINTE MOBILE
-----------------------------*/
let targets = [];

function spawnTargets() {
    targets.forEach(t => scene.remove(t));
    targets = [];

    for (let i = 0; i < 5; i++) {
        const geom = new THREE.SphereGeometry(1.5, 16, 16);
        const mat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const target = new THREE.Mesh(geom, mat);

        target.position.set(
            (Math.random() - 0.5) * 100,
            1.5,
            (Math.random() - 0.5) * 100
        );

        target.speed = 0.1 + Math.random() * 0.2;

        scene.add(target);
        targets.push(target);
    }
}

spawnTargets();
setInterval(spawnTargets, 60000); // reset la 60 secunde

/* ---------------------------
        PROIECTILE
-----------------------------*/
let bullets = [];

function shoot(fromObject) {
    const geom = new THREE.SphereGeometry(0.3, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const bullet = new THREE.Mesh(geom, mat);

    bullet.position.copy(fromObject.position);
    bullet.direction = new THREE.Vector3(0, 0, -1).applyQuaternion(fromObject.quaternion);
    bullet.speed = 1;

    bullets.push(bullet);
    scene.add(bullet);
}

/* ---------------------------
        CONTROALE
-----------------------------*/
let keys = {};

document.addEventListener("keydown", e => {
    keys[e.key] = true;

    if (e.key === " ") shoot(tank);      // SPACE → tank shoot
    if (e.key === "Enter") shoot(plane); // ENTER → plane shoot
});

document.addEventListener("keyup", e => keys[e.key] = false);

/* ---------------------------
        LOOP PRINCIPAL
-----------------------------*/
function animate() {
    requestAnimationFrame(animate);

    // Tank control (WASD)
    if (keys["w"]) tank.position.z -= 0.3;
    if (keys["s"]) tank.position.z += 0.3;
    if (keys["a"]) tank.position.x -= 0.3;
    if (keys["d"]) tank.position.x += 0.3;

    // Plane control (arrows)
    if (keys["ArrowUp"]) plane.position.z -= 0.5;
    if (keys["ArrowDown"]) plane.position.z += 0.5;
    if (keys["ArrowLeft"]) plane.position.x -= 0.5;
    if (keys["ArrowRight"]) plane.position.x += 0.5;

    // Targets movement
    targets.forEach(t => {
        t.position.x += Math.sin(Date.now() * 0.001 * t.speed);
        t.position.z += Math.cos(Date.now() * 0.001 * t.speed);
    });

    // Bullets movement
    bullets.forEach((b, i) => {
        b.position.add(b.direction.clone().multiplyScalar(b.speed));

        // collision with targets
        targets.forEach((t, j) => {
            if (b.position.distanceTo(t.position) < 1.5) {
                scene.remove(t);
                scene.remove(b);
                targets.splice(j, 1);
                bullets.splice(i, 1);
            }
        });
    });

    renderer.render(scene, camera);
}

animate();

/* ---------------------------
        REZOLUȚIE FEREASTRĂ
-----------------------------*/
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>

